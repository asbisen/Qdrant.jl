# This file was generated by the Julia OpenAPI Code Generator
# Do not modify this file directly. Modify the OpenAPI specification instead.


@doc raw"""RecommendRequest
Recommendation request. Provides positive and negative examples of the vectors, which can be ids of points that are already stored in the collection, raw vectors, or even ids and vectors combined.  Service should look for the points which are closer to positive examples and at the same time further to negative examples. The concrete way of how to compare negative and positive distances is up to the &#x60;strategy&#x60; chosen.

    QdrantRecommendRequest(;
        shard_key=nothing,
        positive=nothing,
        negative=nothing,
        strategy=nothing,
        filter=nothing,
        params=nothing,
        limit=nothing,
        offset=nothing,
        with_payload=nothing,
        with_vector=nothing,
        score_threshold=nothing,
        var"using"=nothing,
        lookup_from=nothing,
    )

    - shard_key::QdrantShardKeySelector
    - positive::Vector{QdrantRecommendExample} : Look for vectors closest to those
    - negative::Vector{QdrantRecommendExample} : Try to avoid vectors like this
    - strategy::QdrantRecommendStrategy
    - filter::QdrantFilter
    - params::QdrantSearchParams
    - limit::Int64 : Max number of result to return
    - offset::Int64 : Offset of the first result to return. May be used to paginate results. Note: large offset values may cause performance issues.
    - with_payload::QdrantWithPayloadInterface
    - with_vector::QdrantWithVector
    - score_threshold::Float32 : Define a minimal score threshold for the result. If defined, less similar results will not be returned. Score of the returned result might be higher or smaller than the threshold depending on the Distance function used. E.g. for cosine similarity only higher scores will be returned.
    - var"using"::String
    - lookup_from::QdrantLookupLocation
"""
Base.@kwdef mutable struct QdrantRecommendRequest <: OpenAPI.APIModel
    shard_key = nothing # spec type: Union{ Nothing, QdrantShardKeySelector }
    positive::Union{Nothing, Vector} = nothing # spec type: Union{ Nothing, Vector{QdrantRecommendExample} }
    negative::Union{Nothing, Vector} = nothing # spec type: Union{ Nothing, Vector{QdrantRecommendExample} }
    strategy = nothing # spec type: Union{ Nothing, QdrantRecommendStrategy }
    filter = nothing # spec type: Union{ Nothing, QdrantFilter }
    params = nothing # spec type: Union{ Nothing, QdrantSearchParams }
    limit::Union{Nothing, Int64} = nothing
    offset::Union{Nothing, Int64} = nothing
    with_payload = nothing # spec type: Union{ Nothing, QdrantWithPayloadInterface }
    with_vector = nothing # spec type: Union{ Nothing, QdrantWithVector }
    score_threshold::Union{Nothing, Float32} = nothing
    var"using"::Union{Nothing, String} = nothing
    lookup_from = nothing # spec type: Union{ Nothing, QdrantLookupLocation }

    function QdrantRecommendRequest(shard_key, positive, negative, strategy, filter, params, limit, offset, with_payload, with_vector, score_threshold, var"using", lookup_from, )
        OpenAPI.validate_property(QdrantRecommendRequest, Symbol("shard_key"), shard_key)
        OpenAPI.validate_property(QdrantRecommendRequest, Symbol("positive"), positive)
        OpenAPI.validate_property(QdrantRecommendRequest, Symbol("negative"), negative)
        OpenAPI.validate_property(QdrantRecommendRequest, Symbol("strategy"), strategy)
        OpenAPI.validate_property(QdrantRecommendRequest, Symbol("filter"), filter)
        OpenAPI.validate_property(QdrantRecommendRequest, Symbol("params"), params)
        OpenAPI.validate_property(QdrantRecommendRequest, Symbol("limit"), limit)
        OpenAPI.validate_property(QdrantRecommendRequest, Symbol("offset"), offset)
        OpenAPI.validate_property(QdrantRecommendRequest, Symbol("with_payload"), with_payload)
        OpenAPI.validate_property(QdrantRecommendRequest, Symbol("with_vector"), with_vector)
        OpenAPI.validate_property(QdrantRecommendRequest, Symbol("score_threshold"), score_threshold)
        OpenAPI.validate_property(QdrantRecommendRequest, Symbol("using"), var"using")
        OpenAPI.validate_property(QdrantRecommendRequest, Symbol("lookup_from"), lookup_from)
        return new(shard_key, positive, negative, strategy, filter, params, limit, offset, with_payload, with_vector, score_threshold, var"using", lookup_from, )
    end
end # type QdrantRecommendRequest

const _property_types_QdrantRecommendRequest = Dict{Symbol,String}(Symbol("shard_key")=>"QdrantShardKeySelector", Symbol("positive")=>"Vector{QdrantRecommendExample}", Symbol("negative")=>"Vector{QdrantRecommendExample}", Symbol("strategy")=>"QdrantRecommendStrategy", Symbol("filter")=>"QdrantFilter", Symbol("params")=>"QdrantSearchParams", Symbol("limit")=>"Int64", Symbol("offset")=>"Int64", Symbol("with_payload")=>"QdrantWithPayloadInterface", Symbol("with_vector")=>"QdrantWithVector", Symbol("score_threshold")=>"Float32", Symbol("using")=>"String", Symbol("lookup_from")=>"QdrantLookupLocation", )
OpenAPI.property_type(::Type{ QdrantRecommendRequest }, name::Symbol) = Union{Nothing,eval(Base.Meta.parse(_property_types_QdrantRecommendRequest[name]))}

function check_required(o::QdrantRecommendRequest)
    o.limit === nothing && (return false)
    true
end

function OpenAPI.validate_property(::Type{ QdrantRecommendRequest }, name::Symbol, val)
    if name === Symbol("limit")
        OpenAPI.validate_param(name, "QdrantRecommendRequest", :format, val, "uint")
    end
    if name === Symbol("limit")
        OpenAPI.validate_param(name, "QdrantRecommendRequest", :minimum, val, 1, false)
    end
    if name === Symbol("offset")
        OpenAPI.validate_param(name, "QdrantRecommendRequest", :format, val, "uint")
    end
    if name === Symbol("offset")
        OpenAPI.validate_param(name, "QdrantRecommendRequest", :minimum, val, 0, false)
    end
    if name === Symbol("score_threshold")
        OpenAPI.validate_param(name, "QdrantRecommendRequest", :format, val, "float")
    end
end
